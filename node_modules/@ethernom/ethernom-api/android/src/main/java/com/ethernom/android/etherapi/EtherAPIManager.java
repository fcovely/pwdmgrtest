package com.ethernom.android.etherapi;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import androidx.core.util.Pair;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;

import org.json.JSONObject;
import org.json.JSONArray;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import static com.ethernom.android.etherapi.EtherError.ETH_SUCCESS;


class EtherAPIManager extends ReactContextBaseJavaModule {

    public static final String TAG = "EtherAPIManager";


    private HashMap<Integer,EtherAPI> etherApiInstances= new HashMap<Integer,EtherAPI>();
    private static Integer instanceCount = 0;

    private Context _context;
    private ReactApplicationContext reactContext;

    public ReactApplicationContext getReactContext() {
        return reactContext;
    }

    public EtherAPIManager(ReactApplicationContext reactContext) {
        super(reactContext);
        _context = reactContext;
        this.reactContext = reactContext;

        //Log.d(TAG, "etherapimanager created");
    }
//adb logcat -s ReactNative:V, ReactNativeJS:V, EtherAPIManager:V
    @Override
    public String getName() {
        return "EtherAPIManager";
    }

    public void onActivityResult(int requestCode, int resultCode, Intent data) {
       //Log.d(TAG, "onActivityResult");
    }

    // etherapi methods proper
    @ReactMethod
    public void _InitAPI(final String adapterConnectionString, int servicePort, int secsTimeout, boolean allowDuplicates, boolean stopScanOnWrite, final Callback callback ) {
        //Log.d(TAG,"init api");

        EtherAPI _etherApi = new EtherAPI(adapterConnectionString, (byte)servicePort, (long)secsTimeout,  allowDuplicates,  stopScanOnWrite, _context);
        etherApiInstances.put(instanceCount++,_etherApi);
       //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi.thisId));
        callback.invoke(ETH_SUCCESS, instanceCount - 1);
    }

    @ReactMethod
    public void _InitDFUAPI(final String adapterConnectionString, final String UUID, int secsTimeout, boolean allowDuplicates, boolean stopScanOnWrite, final Callback callback ) {
        //Log.d(TAG,"init DFU api");

        EtherAPI _etherApi = new EtherAPI(adapterConnectionString, UUID, (long)secsTimeout,  allowDuplicates,  stopScanOnWrite, _context);
        etherApiInstances.put(instanceCount++,_etherApi);
        //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi.thisId));
        callback.invoke(ETH_SUCCESS, instanceCount - 1);
    }

    @ReactMethod
    public void _Select(Integer instanceHandle, String deviceID, String deviceName,  final Callback callback) {

            //Log.d(TAG,"_OpenCard");
            EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
            //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi.thisId));
            CardInfo ci = new CardInfo(deviceName,deviceID);
            _etherApi.Select( ci, new SelectListener() {
                @Override
                public void onSelectSuccess(int resultCode) {
                    //Log.d(TAG,"_OpenCard success");
                    callback.invoke(resultCode);
                }

                @Override
                public void onSelectFail(int resultCode, int hwSpecificError) {

                }

                @Override
                public void onDisconnect(int resultCode, int hwSpecificError) {

                }
            });
    }

    private static int ETH_STRING_AS_UNICODE    = 0x01;
	private static int ETH_STRING_AS_HEX	    = 0x02;
    private static int ETH_STRING_AS_ASUTF8     = 0x03;
    private static int ETH_INT_AS_BYTE          = 0x04;
    private static int ETH_INT_AS_2BYTE         = 0x05;
	private static int ETH_INT_AS_4BYTE         = 0x06;
	private static int ETH_AS_ARRAY             = 0x07;
	
    private static int ETH_UNICODESTRING  = 0x11;
    private static int ETH_UTF8STRING     = 0x12;
    private static int ETH_BYTE           = 0x13;
    private static int ETH_2BYTE          = 0x14;
    private static int ETH_PAYLOAD        = 0x15;
	private static int ETH_4BYTE		  = 0x16;


    private List<Byte>  GetEthernomTypeValue(JSONObject jObj, int encoding) {

        try {
            if (encoding == ETH_STRING_AS_UNICODE) {
                String value = jObj.getString("value");
                List<Byte> s = Utils.GetDelimitedString(value);
                return s;
            } else if (encoding == ETH_STRING_AS_ASUTF8) {
                String value = jObj.getString("value");
                List<Byte> cc = Utils.GetDelimitedString(value);
                return cc;
            } else if (encoding == ETH_INT_AS_BYTE) {
                int value = jObj.getInt("value");
                List<Byte> cc = new ArrayList<>();
                cc.add((byte) value);
                return cc;
            } else if (encoding == ETH_INT_AS_2BYTE) {
                int value = jObj.getInt("value");

                List<Byte> cc = new ArrayList<>();
                cc.add((byte) (value & 0xFF));
                cc.add((byte) ((value >> 8) & 0xFF));
                return cc;

            } else if (encoding == ETH_INT_AS_4BYTE) {
                int value = jObj.getInt("value");
                List<Byte> cc = new ArrayList<>();
                cc.add((byte) (value & 0xFF));
                cc.add((byte) ((value >> 8) & 0xFF));
                cc.add((byte) ((value >> 16) & 0xFF));
                cc.add((byte) ((value >> 24) & 0xFF));
                return cc;

            } else if(encoding == ETH_STRING_AS_HEX) {
                String value = jObj.getString("value");
                List<Byte> cc = new ArrayList<>();
                byte[] array = hexStringToByteArray(value);
                for (int i = 0; i < array.length; i++) {
                    cc.add(array[i]);
                }
                return cc;
            } else if(encoding == ETH_AS_ARRAY){
                JSONArray array = jObj.getJSONArray("value");
                List<Byte> cc = new ArrayList<>();
                for(int i=0; i<array.length(); i++){
                    cc.add((byte) array.optInt(i));
                }
                return cc;

            } else {
                //Log.d(TAG, "unknown encoding:" + Integer.toString(encoding));
            }
        } catch (Exception ex) {

        }
        return null;
    }

    private static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }

    private List<Byte> AddToPayload(JSONArray jObj,  List<Byte>currentPayload){
        List<Byte> payload = new ArrayList<Byte>();
        payload.addAll(currentPayload);
        try {
            for (int i = 0; i != jObj.length(); i++){
                JSONObject theObject = jObj.getJSONObject(i);
                Iterator<?> keys = theObject.keys();
                String sk = (String)keys.next();
                Object obj = theObject.get(sk);
                if (obj instanceof String) {
                    String value = theObject.getString(sk);
                    //Log.d(TAG, "String value: " + value);
					
					List<Byte> s = new ArrayList<Byte>();
					if(keys.hasNext()){
						s = Utils.GetDelimitedString(value);
                    }else{
						s = Utils.GetEndedString(value);
					}
					
					payload.addAll(s);
                } else if (obj instanceof Integer) {
                    int value = theObject.getInt(sk);
                    payload.add((byte) value);
                    //Log.d(TAG,"Int value: "+Integer.toString(value));
                } else {
                    // its a full field def
                  //  JSONObject jo = reader.getJSONObject(sk);
                    JSONObject jo = theObject.getJSONObject(sk);
                    // figure out if its a ethernome defined type
                    int xencoding = -1;
                    try{
                        xencoding = jo.getInt("encoding");
                    }
                    catch(Exception ex){

                    }
                    if (xencoding != -1){
                        // an ethernom encoding struct
                        //Log.d(TAG,"ethernom type struct found");
                        List<Byte> p = GetEthernomTypeValue(jo,xencoding);
                        payload.addAll(p);
                    }
                    else {
                        //Log.d(TAG,"json struct found");
                        JSONArray jsonArray = new JSONArray();
                        jsonArray.put(theObject);
                        List<Byte> p = AddToPayload(jsonArray, currentPayload);
                        payload.addAll(p);
                    }
                    //Log.d(TAG, jo.toString());
                }
            }
        }
        catch(Exception ex){
            //Log.d(TAG, ex.getMessage());
        }
        return payload;
    }


    private String parseToOutputJSON(byte[] payload, String outputJSONDef){
        JSONObject jcc = new JSONObject();
        int pp = 0;
        try {
            JSONArray jarray = new JSONArray(outputJSONDef);

            //def
            for (int j = 0; j != jarray.length(); j++){
                
                if(pp == payload.length){
                	break;
                }
                
                JSONObject def = jarray.getJSONObject(j);
                Iterator<?> keys = def.keys();
                String sk = (String)keys.next();

                int etype = def.getInt(sk);
                if (etype == ETH_BYTE ) {
                    int val = payload[pp];
                    if(val < 0){
                        val = val & 0xFF;
                    }
                    pp += 1;
                    jcc.put(sk, val);
                }
                else if (etype == ETH_2BYTE) {
                    int val = ((payload[pp+1] & 0xFF) << 8) | (payload[pp] & 0xFF);
                    if(val < 0){
                        val = val & 0xFFFF;
                    }
                    pp += 2;
                    jcc.put(sk,val);
                }
				else if (etype == ETH_4BYTE) {
                    ByteBuffer buffer = ByteBuffer.allocate(8).put(new byte[]{0, 0, 0, 0,payload[pp+3], payload[pp+2], payload[pp+1],payload[pp]});
					buffer.position(0);
					long lcc =  buffer.getLong();
                    pp += 4;
					jcc.put(sk,lcc);
                }
                else if (etype == ETH_UTF8STRING ) {
                    ArrayList<Byte> bytes = new ArrayList<Byte>();
                    while((payload[pp] != EtherTransportProtocol.DELIMITER) && (payload[pp]!= (byte)0)){
                        byte b = payload[pp];
                        bytes.add(b);
                        pp += 1;
                    }
                    pp += 1; // past delims
                    byte [] data = Utils.ByteListtobyteArray(bytes);
                    String s = new String(data, Charset.forName("UTF-8"));
                    jcc.put(sk,s);
                }
                else if (etype == ETH_PAYLOAD ) {
                    JSONArray arr = new JSONArray();
                    for(int i=0; i<payload.length; i++){
                        int val = payload[i];
                        if(val < 0){
                            val = val & 0xFF;
                        }
                        arr.put(val);
                    }
                    jcc.put(sk, arr);
                }
            }
        }
        catch(Exception ex){
            //Log.d(TAG,ex.getMessage());
        }
        return jcc.toString();
    }


    @ReactMethod
    public void _WriteJSON( Integer instanceHandle, String json, final String outPutJSONDef, final Callback callback){
        final EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst writeJSON: " + Integer.toString(_etherApi.thisId));

        try {
            JSONArray jobj = new JSONArray(json);
            List<Byte> payload = new ArrayList<Byte>();

            List<Byte> finalPayload = AddToPayload(jobj, payload);

            Byte[] bytes = finalPayload.toArray(new Byte[finalPayload.size()]);

            byte [] data = Utils.BytetobyteArray(bytes);

            _etherApi.Write(data, new ReadListener() {
                @Override
                public void onReadSuccess(int resultCode, byte[] payload) {
                    //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener();
                    String retJSON = parseToOutputJSON(payload, outPutJSONDef);
                    callback.invoke(resultCode,retJSON );
                }

                @Override
                    public void onReadFail(int resultCode, int hwSpecificError) {
                    _etherApi.ClearReadListener();
                    callback.invoke(resultCode, hwSpecificError);
                }
            });
        }
        catch(Exception ex){
            //Log.d(TAG, ex.getMessage());
        }
    }

    @ReactMethod
    public void _WriteJSON_DL( Integer instanceHandle, String json, final String outPutJSONDef, final Callback callback){
        final EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst writeJSON_DL: " + Integer.toString(_etherApi.thisId));

        try {
            JSONArray jobj = new JSONArray(json);
            List<Byte> payload = new ArrayList<Byte>();

            List<Byte> finalPayload = AddToPayload(jobj, payload);

            Byte[] bytes = finalPayload.toArray(new Byte[finalPayload.size()]);

            byte [] data = Utils.BytetobyteArray(bytes);

            _etherApi.Write_DL(data, new ReadListener() {
                @Override
                public void onReadSuccess(int resultCode, byte[] payload) {
                    //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener();
                    String retJSON = parseToOutputJSON(payload, outPutJSONDef);
                    callback.invoke(resultCode,retJSON );
                }

                @Override
                public void onReadFail(int resultCode, int hwSpecificError) {
                    _etherApi.ClearReadListener();
                    callback.invoke(resultCode, hwSpecificError);
                }
            });
        }
        catch(Exception ex){
            //Log.d(TAG, ex.getMessage());
        }
    }

    @ReactMethod
    public void _WriteJSON_Generic( Integer instanceHandle, String json, final String outPutJSONDef, final Callback callback){
        final EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst writeJSON_DL: " + Integer.toString(_etherApi.thisId));

        try {
            JSONArray jobj = new JSONArray(json);
            List<Byte> payload = new ArrayList<Byte>();

            List<Byte> finalPayload = AddToPayload(jobj, payload);

            Byte[] bytes = finalPayload.toArray(new Byte[finalPayload.size()]);

            byte [] data = Utils.BytetobyteArray(bytes);

            _etherApi.Write_Generic(data, new ReadListener() {
                @Override
                public void onReadSuccess(int resultCode, byte[] payload) {
                    //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener();
                    String retJSON = parseToOutputJSON(payload, outPutJSONDef);
                    callback.invoke(resultCode,retJSON );
                }

                @Override
                public void onReadFail(int resultCode, int hwSpecificError) {
                    _etherApi.ClearReadListener();
                    callback.invoke(resultCode, hwSpecificError);
                }
            });
        }
        catch(Exception ex){
            //Log.d(TAG, ex.getMessage());
        }
    }

    @ReactMethod
    public void _CardClose(Integer instanceHandle, final Callback callback) {
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst _CardClose: " + Integer.toString(_etherApi.thisId));
        _etherApi.CardClose(new CardCloseListener() {
            @Override
            public void onCardCloseSuccess(int resultCode) {
				if(callback != null){
					callback.invoke(resultCode);
				}
            }

            @Override
            public void onCardCloseFail(int resultCode, int hwSpecificError) {

            }
        });
    }

    @ReactMethod
    public void _onCardDisconnected(Integer instanceHandle, final String callbackEventName) {
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst _onCardDisconnected: " + Integer.toString(_etherApi.thisId));
        _etherApi.OnCardDisconnected(new ConnectionEventListener() {
             @Override
             public void onConnectionDropped(int resultCode) {
                 WritableMap params = Arguments.createMap();
                 params.putInt("resultCode", resultCode);
                 // Get EventEmitter from context and send event thanks to it
                 reactContext
                         .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                         .emit(callbackEventName, params);
             }
         });
    }

    @ReactMethod
    public void _SubscribeToUnsolictedEvents(Integer instanceHandle, final String outPutJSONDef, final String callbackEventName) {
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst __SubscribeToUnsolictedEvents: " + Integer.toString(_etherApi.thisId));
        _etherApi.SubscribeToUnsolictedEvents(new UnSolicitedEventListener() {
            @Override
            public void onUnsolicitedEvent(int resultCode, byte[] payload) {
                String retJSON = parseToOutputJSON(payload, outPutJSONDef);
                WritableMap params = Arguments.createMap();
                // Put data to map
                params.putInt("resultCode", resultCode);
                params.putString("msgJSON", retJSON);
                // Get EventEmitter from context and send event thanks to it
                reactContext
                        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                        .emit(callbackEventName, params);
            }
        });
    }

    @ReactMethod
    public void _UnSubscribeToUnsolictedEvents(Integer instanceHandle, final String callbackEventName) { // dont really need event but passed for symmetry and when we add multpile event listeners
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"__SubscribeToUnsolictedEvents");
        // simply unhook the callback, React unhooks it on the js thread side
        _etherApi.ClearUnsolicitedEventListener();
    }

    @ReactMethod
    public void _StopDiscovery(Integer instanceHandle) {
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst _StopDiscovery: " + Integer.toString(_etherApi.thisId));
        _etherApi.StopDiscovery();
    }


    @ReactMethod
    public void _DiscoverDevices(Integer instanceHandle, final String callbackEventName) {
        EtherAPI _etherApi = etherApiInstances.get(instanceHandle);
        //Log.d(TAG,"etherinst _Discover: " + Integer.toString(_etherApi.thisId));

        _etherApi.DiscoverDevices(new DiscoverServiceListener() {
            @Override
            public void onServiceDiscover(int resultCode, String deviceID, String deviceName) {
                WritableMap params = Arguments.createMap();
                // Put data to map
                params.putInt("resultCode", resultCode);
                params.putString("deviceID", deviceID);
                params.putString("deviceName", deviceName);
                // Get EventEmitter from context and send event thanks to it
                reactContext
                        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                        .emit(callbackEventName, params);
                //callback.invoke(resultCode, deviceID, deviceName);
            }

            @Override
            public void onServiceDiscoverFail(int resultCode, int hwSpecificError) {

            }

            @Override
            public void onServiceDiscoverEnd(int resultCode) {

            }
        });
    }
}
