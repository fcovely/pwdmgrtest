package com.ethernom.android.etherapi;


// this class implements the ethernom transport layer
// the class enforces a TCP port concept via a common interface in Link layer components

import android.util.Log;

import com.ethernom.android.etherapi.linkLayer.EtherCommAdapter;
import com.ethernom.android.etherapi.linkLayer.TInterface;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class EtherTransportProtocol {
    static String TAG= "EtherTransportProtocol";


    private byte _servicePort;
    private byte _generic_servicePort = (byte)0x16;
    private byte _downloader_servicePort = (byte)0x14;
    private TMessageProtocol _messageProtocol;
    private CardInfo _cardInfo;
    private TInterface _interfaceKind;

    private byte control = (byte)0x0;
    static int  DELIMITER   = 31;
    public static int  ETH_HEADER_SIZE = 8;
    public static int  ETH_PAYLOAD_HEAD = ETH_HEADER_SIZE + 1;


    public EtherTransportProtocol(byte servicePort, TInterface interfaceKind, TMessageProtocol messageProtocol){
        _servicePort = servicePort;
        _messageProtocol = messageProtocol;
        _interfaceKind = interfaceKind;
    }

    public byte GetServicePort(){return _servicePort;}
    public byte GetGenericPort(){return _generic_servicePort;}
    public byte GetDLPort(){return _downloader_servicePort;}

    String getStringRepresentation(ArrayList<Character> list)
    {
        StringBuilder builder = new StringBuilder(list.size());
        for(Character ch: list)
        {
            builder.append(ch);
        }
        return builder.toString();
    }

    public byte [] GetApplicationData(byte [] data){
        try {
            int len = data.length - ETH_HEADER_SIZE;
            int start = ETH_HEADER_SIZE;
            byte[] slice = Arrays.copyOfRange(data, start, start+len);
            return slice;
        }
        catch(Exception ex){
            Log.d("foo", ex.getMessage());
        }
        return null;
    }

    private ArrayList<String> CrackTransportPacket( byte [] data){
        ArrayList<String> items = new ArrayList<>();
        ArrayList<Character> temp = new ArrayList<>();
        int startingPoint = ETH_PAYLOAD_HEAD;

        int i = 0;
        for (int j =0; j != data.length; j++){
            if (i >= startingPoint){
                byte uc = data[j];
                if (uc == DELIMITER) {
                    String s = getStringRepresentation(temp);
                    items.add(s);
                    temp.clear();
                } else {
                    temp.add((char)uc);
                }
            }
            i += 1;
        }

        return items;
    }


    public byte GetTransportMessageCheckSum(byte [] packet){
        int xorValue = packet[0];

        // xor the packet header for checksum
        int i = 0;
        for (int j =1; j != 7; j++){
            int c = packet[j];
            xorValue = xorValue ^ c;
        }
        return (byte) xorValue;
    }

    //*******************************************************************
    //*********************APP WRITE**************************************
    //*******************************************************************
    public byte [] getTransportHeader(int payloadLength) {
        byte [] packet = new byte[ETH_HEADER_SIZE];
        packet[0] = (byte)(_servicePort | 0x80);
        packet[1] = _servicePort ;
        packet[2] = control;
        //packet[3] = (byte) _interfaceKind.ordinal();
        packet[3] = (byte) 0x02;


        // length bytes, length is 2 bytes
        int Value0 = payloadLength & 0x00ff;
        int Value1 = payloadLength >> 8;
        packet[4] = (byte)Value0;
        packet[5] = (byte)Value1;
        packet[6] = (byte)_messageProtocol.ordinal();
        packet[7] = (byte)0;

        int xorValue = packet[0];

        packet[7] = GetTransportMessageCheckSum(packet);
        return packet;
    }
    private byte [] makeTransportPacket(List<Byte> payload){
        byte[] payloadBytes = new byte[payload.size()];
        for (int i = 0; i < payload.size(); i++) {
            payloadBytes [i] = (byte)payload.get(i);
        }
        // Length of payload (without Transport Header), get back a viable header missing only the checksum

        byte [] packetHeader = getTransportHeader(payload.size());
        byte[] c = new byte[packetHeader.length + payloadBytes.length];
        System.arraycopy(packetHeader, 0, c, 0, packetHeader.length);

        System.arraycopy(payloadBytes, 0, c, packetHeader.length, payloadBytes.length);
        return c;
    }

    // PAYLOADS REQUIRING JUST A COMMAND
    public  byte [] GetPayload(int cmd ) {
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        payload.add((byte)0);
        return makeTransportPacket(payload);
    }

    // PAYLOADS WITH A COMMAND BYTE
    public byte [] GetPayload(byte cmd, byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket(payload);
    }


    // STRING PAYLOAD
    public byte [] GetPayload(String data) {
        return GetPayload(data.getBytes());
    }

    // STRING WITH COMMAND BYTE
    public byte [] GetPayload(byte cmd, String data) {
        return GetPayload(cmd, data.getBytes());
    }

    // RAW BYTE PAYLOADS JUST IN CASE
    public byte [] GetPayload(byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket(payload);
    }


    // MAJOR USE CASE, PAYLOAD BASED ON A COMMAND AND A STRING ARRAY
    public  byte[] GetPayload(int cmd,  String [] data){
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        if (data.length == 0) {
            payload.add((byte)0);
        } else {
            int cc = 0;
            for(int i =0; i != data.length; i++){
                String item = data[i];
                for(int j=0; j!= item.length(); j++){
                    char c = item.charAt(j);
                    byte b = (byte)c;
                    payload.add(b);
                }
                if (cc < data.length - 1) {
                    payload.add((byte)DELIMITER);
                }
                cc = cc+ 1;
            }
            payload.add((byte)0);
        }

        return makeTransportPacket(payload);
    }

    //*******************************************************************
    //*********************DL WRITE**************************************
    //*******************************************************************
    //DOWNLOADER TRANSPORT WRITE
    public byte [] getTransportHeader_DL(int payloadLength) {
        byte [] packet = new byte[ETH_HEADER_SIZE];
        packet[0] = (byte)(_downloader_servicePort | 0x80);
        packet[1] = _downloader_servicePort ;
        packet[2] = control;
        //packet[3] = (byte) _interfaceKind.ordinal();
        packet[3] = (byte) 0x02;

        // length bytes, length is 2 bytes
        int Value0 = payloadLength & 0x00ff;
        int Value1 = payloadLength >> 8;
        packet[4] = (byte)Value0;
        packet[5] = (byte)Value1;
        packet[6] = (byte)_messageProtocol.ordinal();
        packet[7] = (byte)0;

        int xorValue = packet[0];

        packet[7] = GetTransportMessageCheckSum(packet);
        return packet;
    }

    private byte [] makeTransportPacket_DL(List<Byte> payload){
        byte[] payloadBytes = new byte[payload.size()];
        for (int i = 0; i < payload.size(); i++) {
            payloadBytes [i] = (byte)payload.get(i);
        }
        // Length of payload (without Transport Header), get back a viable header missing only the checksum

        byte [] packetHeader = getTransportHeader_DL(payload.size());
        byte[] c = new byte[packetHeader.length + payloadBytes.length];
        System.arraycopy(packetHeader, 0, c, 0, packetHeader.length);

        System.arraycopy(payloadBytes, 0, c, packetHeader.length, payloadBytes.length);
        return c;
    }

    // PAYLOADS REQUIRING JUST A COMMAND
    public  byte [] GetPayload_DL(int cmd ) {
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        payload.add((byte)0);
        return makeTransportPacket_DL(payload);
    }

    // PAYLOADS WITH A COMMAND BYTE
    public byte [] GetPayload_DL(byte cmd, byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket_DL(payload);
    }

    // STRING PAYLOAD
    public byte [] GetPayload_DL(String data) {
        return GetPayload_DL(data.getBytes());
    }

    // STRING WITH COMMAND BYTE
    public byte [] GetPayload_DL(byte cmd, String data) {
        return GetPayload_DL(cmd, data.getBytes());
    }

    // RAW BYTE PAYLOADS JUST IN CASE
    public byte [] GetPayload_DL(byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket_DL(payload);
    }

    // MAJOR USE CASE, PAYLOAD BASED ON A COMMAND AND A STRING ARRAY
    public  byte[] GetPayload_DL(int cmd,  String [] data){
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        if (data.length == 0) {
            payload.add((byte)0);
        } else {
            int cc = 0;
            for(int i =0; i != data.length; i++){
                String item = data[i];
                for(int j=0; j!= item.length(); j++){
                    char c = item.charAt(j);
                    byte b = (byte)c;
                    payload.add(b);
                }
                if (cc < data.length - 1) {
                    payload.add((byte)DELIMITER);
                }
                cc = cc+ 1;
            }
            payload.add((byte)0);
        }

        return makeTransportPacket_DL(payload);
    }

    //*******************************************************************
    //*********************DL WRITE**************************************
    //*******************************************************************
    //DOWNLOADER TRANSPORT WRITE
    public byte [] getTransportHeader_Generic(int payloadLength) {
        byte [] packet = new byte[ETH_HEADER_SIZE];
        packet[0] = (byte)(_generic_servicePort | 0x80);
        packet[1] = _generic_servicePort ;
        packet[2] = control;
        //packet[3] = (byte) _interfaceKind.ordinal();
        packet[3] = (byte) 0x02;

        // length bytes, length is 2 bytes
        int Value0 = payloadLength & 0x00ff;
        int Value1 = payloadLength >> 8;
        packet[4] = (byte)Value0;
        packet[5] = (byte)Value1;
        packet[6] = (byte)_messageProtocol.ordinal();
        packet[7] = (byte)0;

        int xorValue = packet[0];

        packet[7] = GetTransportMessageCheckSum(packet);
        return packet;
    }

    private byte [] makeTransportPacket_Generic(List<Byte> payload){
        byte[] payloadBytes = new byte[payload.size()];
        for (int i = 0; i < payload.size(); i++) {
            payloadBytes [i] = (byte)payload.get(i);
        }
        // Length of payload (without Transport Header), get back a viable header missing only the checksum

        byte [] packetHeader = getTransportHeader_Generic(payload.size());
        byte[] c = new byte[packetHeader.length + payloadBytes.length];
        System.arraycopy(packetHeader, 0, c, 0, packetHeader.length);

        System.arraycopy(payloadBytes, 0, c, packetHeader.length, payloadBytes.length);
        return c;
    }

    // PAYLOADS REQUIRING JUST A COMMAND
    public  byte [] GetPayload_Generic(int cmd ) {
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        payload.add((byte)0);
        return makeTransportPacket_Generic(payload);
    }

    // PAYLOADS WITH A COMMAND BYTE
    public byte [] GetPayload_Generic(byte cmd, byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket_Generic(payload);
    }

    // STRING PAYLOAD
    public byte [] GetPayload_Generic(String data) {
        return GetPayload_Generic(data.getBytes());
    }

    // STRING WITH COMMAND BYTE
    public byte [] GetPayload_Generic(byte cmd, String data) {
        return GetPayload_DL(cmd, data.getBytes());
    }

    // RAW BYTE PAYLOADS JUST IN CASE
    public byte [] GetPayload_Generic(byte [] data) {
        // Construct payload as series of delimited stringsƒsƒs
        List<Byte> payload = new ArrayList<Byte>();
        for (int i =0; i != data.length; i++)
            payload.add(data[i]);
        return makeTransportPacket_Generic(payload);
    }

    // MAJOR USE CASE, PAYLOAD BASED ON A COMMAND AND A STRING ARRAY
    public  byte[] GetPayload_Generic(int cmd,  String [] data){
        // Construct payload as series of delimited strings
        List<Byte> payload = new ArrayList<Byte>();
        payload.add((byte)cmd);
        if (data.length == 0) {
            payload.add((byte)0);
        } else {
            int cc = 0;
            for(int i =0; i != data.length; i++){
                String item = data[i];
                for(int j=0; j!= item.length(); j++){
                    char c = item.charAt(j);
                    byte b = (byte)c;
                    payload.add(b);
                }
                if (cc < data.length - 1) {
                    payload.add((byte)DELIMITER);
                }
                cc = cc+ 1;
            }
            payload.add((byte)0);
        }

        return makeTransportPacket_Generic(payload);
    }
}
